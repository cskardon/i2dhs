```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Packages}
library('tidyverse')
library('sf')
source('functions.r')
library('here')
library('plotly')
```

```{r Constants}
max_alpha <- 0.5
```

```{r 'Read in boundary map'}
scotland_la_boundary_map_path <- here('maps/Local_Authority_Boundaries_-_Scotland.json')
map_scotland_la_boundary <- st_read(scotland_la_boundary_map_path)
```

```{r 'Plot the map (Base R)'}
#plot(map_scotland_la_boundary$geometry, col = 'white')
```



```{r 'Highlight one authority'}
# local_authority = 'Dumfries and Galloway'
# map_local_authority_highlight = map_scotland_la_boundary[map_scotland_la_boundary$local_authority == local_authority, ] 

# #NB. add=TRUE allows the above plot to be augmented with the highlighting, as opposed to plotting afresh.
# plot(st_geometry(map_local_authority_highlight), col = 'red', add=TRUE)
```

Reading in the CSV file with the local authorities in.

```{r 'Read ScotPHO dataset'}
scotpho_data_path <- here('data/ScotPHO - anxiety, depression, psychosis - local authorities- all years.csv')
df_scotpho = read_csv(scotpho_data_path)
```

Need to tweak the data naming of Local Authorities:

* The GeoJSON output uses `and` instead of `&`
* In GeoJSON we have `Na h-Eileanan an Iar` in the ScotPHO data we have `Na h-Eileanan Siar`

It is easier to do a replace all on the dataframe than the GeoJSON file. See the [`functions.r`](./functions.r) file for the definition
Also - yes - we could _store_ the file with the updates, but the time taken is minimal, and every dataset with the ScotPHO names would need to be updated.

```{r 'Tidy data for use in map'}
df_scotpho = tidy_names_of_scotpho_la_for_maps(df_scotpho)
```

If all the naming of the local authorites in the DataFrame is now correct - then the entire map should be coloured in orange.

```{r 'Test if colouring map works'}
# for(i in 1:nrow(df_scotpho)){
#     la_name = df_scotpho[i, ]$area_name
#     highlight <- map_scotland_la_boundary[map_scotland_la_boundary$local_authority == la_name, ] 
#     plot(st_geometry(highlight), col = '#443322AA', add=TRUE)
# }
```

It does - this is commented out due to the way I do the 2018 medication representation below (using the ALPHA).

So there are 32 LAs

```{r}
greenspace <- read_csv('./data/3rd-state-of-scotlands-greenspace-appendix-6-4.csv')
```


```{r}
# Only pulling 2018 for this as that's all the data we have
df_scotpho_totals <- df_scotpho |> 
    filter(year == 2018) |> 
    select(`area_name`, `measure`)

min_measure = min(df_scotpho_totals$measure) # This is the minimum % measurement in the data
max_measure = max(df_scotpho_totals$measure) # This is the max ^^
diff_measure = max_measure - min_measure # This gets the difference between min and max - so we can...

# Calculate the 'alpha' (opacity) value of colours per '.1' percent.
# The data is rounded to 1dp, so we do (diff_measure * 10) to remove the dp
# We divide 1 by ^ because 1 is 'full' opacity (i.e. opaque).
alpha_step = max_alpha / (diff_measure * 10) 
```

Alpha will essentially become:
`diff from min value * alpha_step`

We'll use blue (i.e. `RGB(0,0,0, calc_alpha)`) to render the colours, so I need to mutate the df


```{r}
df_scotpho_withcolour <- df_scotpho_totals

# This adds the full hex code for the colour to the DF
df_scotpho_withcolour$colour <- rgb(0,0,1, ((df_scotpho_withcolour$measure - min_measure) * 10) * alpha_step)
```



```{r "ggplot2 version"}
mapPlot <- ggplot(map_scotland_la_boundary) +
    ggtitle("% Population prescribed drugs for anxiety, depression and psychosis") + 
    geom_sf(fill = "white", color = "grey") +
    theme_void()

for(i in 1:nrow(df_scotpho_withcolour)){
    # Get the name of the Local Authority
    la_name <- df_scotpho_withcolour[i, ]$area_name
    # Finds the boundary to colour by the `la_name`
    highlight <- map_scotland_la_boundary[map_scotland_la_boundary$local_authority == la_name, ] 
    # Plots this highlight over the existing map.
    mapPlot <- mapPlot +
        geom_sf(data=highlight, fill = df_scotpho_withcolour[i, ]$colour) 
}

mapPlot <- mapPlot +
    geom_sf_label(aes(label = local_authority), size = 3, color = "black", fill = "white") 

mapPlot 
```


```{r}
# Only pulling 2018 for this as that's all the data we have
df_greenspace_percent <- greenspace |> 
    select(`Local Authority`, `Total Area of Greenspace (ha)`, `Area of publicly accessible greenspace (ha)`) |> 
    rename('local_authority' = `Local Authority` ) |> 
    mutate(percentAccessible = (`Area of publicly accessible greenspace (ha)` / `Total Area of Greenspace (ha)`) * 100)

min_gs_measure = min(df_greenspace_percent$percentAccessible) # This is the minimum % measurement in the data
max_gs_measure = max(df_greenspace_percent$percentAccessible) # This is the max ^^
diff_gs_measure = max_gs_measure - min_gs_measure # This gets the difference between min and max - so we can...

# Calculate the 'alpha' (opacity) value of colours per '.1' percent.
# The data isn't rounded, so we'll use 2dp, so we do (diff_measure * 100) to remove the dp
# We divide 1 by ^ because 1 is 'full' opacity (i.e. opaque).
alpha_gs_step = max_alpha / (diff_gs_measure * 10) 
```


```{r}
df_greenspace_withcolour <- df_greenspace_percent

# This adds the full hex code for the colour to the DF
df_greenspace_withcolour$colour <- rgb(0,1,0, ((df_greenspace_withcolour$percentAccessible - min_gs_measure) * 10) * alpha_gs_step)
```

```{r "ggplot2 version"}
greenspacePlot <- ggplot(map_scotland_la_boundary) +
    ggtitle("Combined") + 
    geom_sf(fill = "white", color = "grey") +
    theme_void()

for(i in 1:nrow(df_greenspace_withcolour)){
    # Get the name of the Local Authority
    la_name <- df_greenspace_withcolour[i, ]$local_authority
    # Finds the boundary to colour by the `la_name`
    highlight <- map_scotland_la_boundary[map_scotland_la_boundary$local_authority == la_name, ] 
    # Plots this highlight over the existing map.
    greenspacePlot <- greenspacePlot +
        geom_sf(data=highlight, fill = df_greenspace_withcolour[i, ]$colour) 
}

greenspacePlot <- greenspacePlot +
    geom_sf_label(aes(label = local_authority), size = 3, color = "black", fill = "white") 

greenspacePlot 
```

```{r "ggplot2 version"}
combinedPlot <- ggplot(map_scotland_la_boundary) +
    ggtitle("% Greenspace accessible") + 
    geom_sf(fill = "white", color = "grey") +
    theme_void()

for(i in 1:nrow(df_greenspace_withcolour)){
    # Get the name of the Local Authority
    la_name <- df_greenspace_withcolour[i, ]$local_authority
    # Finds the boundary to colour by the `la_name`
    highlight <- map_scotland_la_boundary[map_scotland_la_boundary$local_authority == la_name, ] 
    # Plots this highlight over the existing map.
    combinedPlot <- combinedPlot +
        geom_sf(data=highlight, fill = df_greenspace_withcolour[i, ]$colour) 
}

for(i in 1:nrow(df_scotpho_withcolour)){
    # Get the name of the Local Authority
    la_name <- df_scotpho_withcolour[i, ]$area_name
    # Finds the boundary to colour by the `la_name`
    highlight <- map_scotland_la_boundary[map_scotland_la_boundary$local_authority == la_name, ] 
    # Plots this highlight over the existing map.
    combinedPlot <- combinedPlot +
        geom_sf(data=highlight, fill = df_scotpho_withcolour[i, ]$colour) 
}

combinedPlot <- combinedPlot +
    geom_sf_label(aes(label = local_authority), size = 3, color = "black", fill = "white") 

combinedPlot 
```




```{r}
#Does nothing, but allows you to use 'Run Above'
```